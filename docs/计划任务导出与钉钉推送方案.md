# 计划任务自动导出与钉钉推送方案

## 1. 背景与问题

当前系统中：

1. `计划任务` 仅负责按时间触发扫描，不负责结果通知。  
2. 监控类任务（如资产站点/WIH 监控）已有消息推送能力，但计划任务链路未接入。  
3. 已有“批量表格导出”能力，但主要服务于手工操作，未形成“计划任务完成后自动导出并通知”的闭环。  

这会导致用户对计划任务的结果感知不及时，影响使用体验和自动化价值。

## 2. 目标

建设一套可扩展的“计划任务结果通知”机制，分阶段实现：

1. 计划任务触发后，扫描完成可自动推送摘要到钉钉。  
2. 支持自动生成批量导出报表，并在消息中附下载方式。  
3. 为后续钉钉开放平台 API 深度对接（文件发送、工作通知、交互卡片等）预留架构。  

## 3. 设计原则

1. **异步化**：导出与推送必须异步执行，不能阻塞调度主循环。  
2. **幂等性**：同一轮计划任务只推送一次，避免重复消息。  
3. **可观测性**：记录每轮计划执行、导出、推送状态，便于排障。  
4. **向后兼容**：默认关闭新能力，不影响现有计划任务行为。  
5. **可扩展**：先支持机器人 Webhook，再扩展钉钉 OpenAPI。  

## 4. 整体方案

### 4.1 方案概述

在现有 `task_schedule` 触发逻辑基础上，新增“计划任务执行实例（run）”概念：

1. 计划任务每触发一次，创建一条 `task_schedule_run` 记录。  
2. 记录本次触发产生的 `task_id` 列表（一个计划任务可能拆成多个扫描任务）。  
3. 后台异步任务轮询本次 `task_id` 的完成状态。  
4. 全部结束后，按配置执行：
   - 仅推送摘要
   - 导出报表 + 推送摘要/链接

### 4.2 关键链路

1. 计划触发：`app/helpers/task_schedule.py`  
2. 任务提交：`app/helpers/task.py`  
3. 导出能力复用：`app/routes/export.py`（建议抽取到 `app/services/export_service.py`）  
4. 推送能力复用：`app/helpers/message_notify.py` 与 `app/utils/push.py`  
5. 调度主循环：`app/scheduler.py`（仅负责触发，不做重活）  

## 5. 分阶段实施

### Phase 1：计划任务完成后钉钉摘要推送（优先）

### 范围

1. 新增计划任务通知配置（默认关闭）。  
2. 计划任务触发时记录 `run` 实例。  
3. 扫描完成后发送钉钉 markdown 摘要（成功数、失败数、耗时、任务ID）。  

### 建议字段

在 `task_schedule` 中新增：

1. `notify_enable`：是否启用通知（bool）  
2. `notify_channel`：通知渠道（先支持 `dingding`）  
3. `notify_on`：触发条件（`finished` / `failed` / `always`）  

新增集合 `task_schedule_run`：

1. `schedule_id`、`schedule_name`  
2. `task_ids`（list）  
3. `status`（`running` / `finished` / `error`）  
4. `push_status`（`pending` / `success` / `error`）  
5. `start_time`、`end_time`  
6. `error_msg`  

### 验收标准

1. 计划任务触发后可创建 `run` 记录。  
2. 全部子任务结束后，钉钉收到摘要消息。  
3. 同一 `run` 不重复推送。  

### Phase 2：自动批量导出 + 推送下载信息

### 范围

1. 在 `run` 完成后自动生成 Excel 报表。  
2. 推送消息中包含报表元信息（文件名、生成时间、下载地址/访问方式）。  
3. 增加导出失败重试与状态记录。  

### 技术建议

1. 将 `export_merge_tasks` 从路由逻辑中抽到服务层，支持后台直接调用。  
2. 产物存储到可控目录（如 `tmp/reports/`），按日期分层。  
3. 增加临时下载令牌或内部访问限制，避免裸露静态文件。  

### 验收标准

1. 任务完成后可自动生成可下载报表。  
2. 钉钉消息可引导用户获取报表。  
3. 导出失败不会影响主任务状态，并可追踪失败原因。  

### Phase 3：钉钉 OpenAPI 深度集成（后续）

### 目标能力

1. 发送文件消息（而非仅 markdown 文本）。  
2. 使用工作通知/群会话 API 精准投递。  
3. 支持更丰富卡片消息（按钮、链接、操作反馈）。  

### 建议新增配置

在配置中增加独立节：

1. `DINGDING.APP_KEY`  
2. `DINGDING.APP_SECRET`  
3. `DINGDING.AGENT_ID`  
4. `DINGDING.DEFAULT_CHAT_ID`  

并保留当前机器人 Webhook 配置，形成双通道：

1. `webhook`（部署简单）  
2. `openapi`（能力更强）  

## 6. 风险与控制

1. **导出耗时高**：必须走 Celery 异步队列，避免阻塞调度线程。  
2. **重复推送**：基于 `task_schedule_run.push_status` 做幂等。  
3. **任务拆分复杂**：统一以 `run.task_ids` 聚合完成态，不依赖单个任务。  
4. **下载安全**：报表必须有过期策略与最小权限访问。  

## 7. 兼容与迁移

1. 对现有计划任务记录做向后兼容：新字段默认值保持“关闭通知”。  
2. 不改已有监控任务推送链路，避免影响已稳定功能。  
3. 配置缺失时自动降级为“不推送、仅记录日志”。  

## 8. 实施清单（建议顺序）

1. 数据模型：`task_schedule` 扩展字段 + 新建 `task_schedule_run`。  
2. 流程改造：`submit_task_schedule` 返回并记录 `task_id` 列表。  
3. 后台任务：新增“run 完成态检查 + 推送” Celery 任务。  
4. 推送模板：新增计划任务摘要 markdown 模板。  
5. 导出服务化：抽取批量导出逻辑到 `services`。  
6. 下载策略：报表存储与访问控制。  
7. 配置文档：补充 `config-docker.yaml` 与运维说明。  
8. 测试：单元测试 + 集成测试 + 幂等测试。  

## 9. 结论

该方案可行，且与现有代码结构兼容。建议按 **Phase 1 -> Phase 2 -> Phase 3** 逐步推进，先快速建立“计划任务可感知”的通知闭环，再演进到钉钉 OpenAPI 的高级能力。
